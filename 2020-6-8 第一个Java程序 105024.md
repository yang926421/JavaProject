# 基础

第一个Java程序

```
public class Hello{
    public static void main(String[] args){
        System.out.printlen("Hello world");
    }
}
```



java 程序严格区分大小写   标点符号必须是英文符号

Java编译文件的时候

1 javac 文件名.java

2 运行  java 类名

java的注释

//  单行注释

/*  */    多行注释

文档注释 是对整个文档进行的注释   /**  */

类是java程序可以被执行的最小单元



变量的意义

​	把程序运行过程中产生的值,方便后面使用

变量和int

## java的数据类型

1 int 整数

```
加减乘除取余
+ - * / %
java中如果左右两边都是int 结果就是int  整数10/20 = 0 余10
```

double 小数

```
 + - * /  % 
 操作和int基本一样 不同的是 double计算的结果一般都是double
 
```

boolean 布尔值

true  false

String 字符串

```
字符串的拼接  运算过程和数学上是一样的,从左到右,先算括号  字符串+int  int也会是字符串  例如lyy+10   lyy10
```

## 用户输入

Scanner

```
先创建个扫描器 需要导包  import java.util.Scanner
Scanner sc = new Scanner(System.in)
类型 变量名 = sc.next...()  获取到要输入的内容
```

## if判断语句

```
if(判断1){
    执行语句1
}
else if(判断2){
    执行语句2
}
else{
都不满足 执行语句3    
}
```

## while循环

```
import java.util.Random;
import java.util.Scanner;
public class homework {
    public static void main(String[] args){
        System.out.println("写一下作业嘛,太low了");
        // 写一个random实例大概
        Random rd = new Random();
        int n = rd.nextInt(100); // n是一个随机数,范围是[0,99]
        System.out.println(n);
        // 用户输入
        System.out.println("来猜一下");
        Scanner sc = new Scanner(System.in);
        boolean flag = true;
        while(flag) {
            int a = sc.nextInt();
            if (a > n) {
                System.out.println("猜大了,继续猜");
            } else if (a < n) {
                System.out.println("猜小了,继续猜");
            } else {
                System.out.println("猜对了");
                flag = false;
            }
        }
    }
}

```

编码

utf - 8 可变长度的unicode

英文 8bit  1byte

欧洲文字  16bit 2byte

中文 14bit 3byte



## 基础数据类型 整数

int 整数  32bit  4byte   -21亿~21亿

byte  java中最小的数据单元  8bit  -128~127 之间

short 短整数  16bit  -32768~32767  2byte

long长整数     64bit 8byte



## 数据类型 小数

双精度小数,精度高,准确性高

double   64bit  8byte(比较大 在内存中是比较浪费的)

单精度小数

float  32bit  4byte



## 基本数据类型_字符

字符 单一的文字符号

char  16bit  unicode标准 定长 

char类型可以存放数字,存放的数字实际上是字符

## 基础数据类型 boolean

boolead 取值范围 true, false

在内存中有0和1 就够了  但是在内存中占用的是8个字节  1byte



基本数据类型小结

整数

​	1 byte字节 8位

​	short 短整数  16bit 2 byte

​	int 整数 32bit 4byte

​	long 长整数  64bit  8byte

小数

​	float 单精度小数 32bit 4 byte

​	double 双精度小数   64bit 8byte

字符

​	char 单一文字符号  16bit 2byte

​	必须用单引号括起来

布尔

​	Boolean  计算机中 8bit 1byte

​	true false

## 基本数据类型转换

顺序 数据量的大小

byte -> short, char -> int -> long -> float -> double 

小数据类型转换成大数据类型   安全,直接转化

大数据类型  -> 小数据类型   不一定安全,可能会出现问题

```
public class TestConvert {
    public static void main(String[] args){
        System.out.println();
        int a = 10;
        long b = a;
        System.out.println(b);
        long c = 10;
        int d = (int)c;
        System.out.println(d);  //小转大  强转尽量限制 可能会有问题


    }
}

```

## 基本数据类型之间的运算

1.相同数据类型之间

​	相同数据类型,得到的一定是这个数据类型

​	int + int = int

​	int / int = int   10/3=3

2.不同数据类型

​	int + long = long

​	首先,把小的数据类型自动转换成大的数据类型,然后再进行计算,得到的结果一定是大的数据类型

3.特殊的short byte short

​	不管什么情况,这种都要特殊对待

​	在计算的时候首先会转换成int再进行运算,这样是安全的

```
面试题
	1.问会打印什么结果
	short s1 = 1;

	short s2 = s1 + 1;

	system.out.println(s2);
	会报错,不打印
```

## 基本运算符,算数运算

```
 + - * /
 public class TestSuan {
    public static void main(String[] args) {
        int a = 10;
        int b = 3;
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println(a/b);
        System.out.println(a%b);
    }
} 
```

## 运算符_赋值扩展运算

```
=  把等号右边的计算结果赋值给等号左边的变量
+=  累加
-=
*=
/=
%=
```

## 运算符 比较运算

```
>
<
>=
<=
==
!=
比较运算的结果 
```

逻辑运算

```
&& 并且  左右两端同时为真 结果才为真
|| or  有一个成立则为True
! 非 
```

## while 循环

```
如果没有break 会产生case穿透现象
一个case被匹配成功,后面的case就不匹配了,但是会执行里面的代码
```

## for循环

for(语句1;语句2; 语句3){

循环体

}

for(int i= 0; i<10; i++){

执行语句

}

## do...while循环

​	while(条件){

​	循环体

}

do...while

do{

​	执行语句

}

while{条件判断}

## break和continue

```
break跳出整个循环
continue跳出单个循环

```

## 数组

具有相同数据类型的集合

java中的数组

类型[] 数组名 = new 类型[大小];

类型[] 数组名 = {数据,数据,数据....};

类型[] 数组名 = new 类型[]{数据,数据,数据}

```
public class shu_list {
    public static void main(String[] args) {
        System.out.println();
        // 三种创建数组的方式
        int[] arr1 = new int[5];
        int[] arr2 = {22, 33, 44};
        int[] arr3 = new int[]{22, 33, 55};
        // 数组必须配合数组的下标进行使用,下标从0开始
        int[] arr4 = {23, 45, 67, 87, 44};
        System.out.println(arr4[4]);
        for (int i=0; i< arr4.length; i++){
            System.out.println(arr4[i]);
        }
    }
}     

```

方法的返回值

```
返回值 :执行方法之后得到的结果
public static 返回值类型 方法名(){
    方法体;
    return 值;
}
注意:
1.返回值类型和返回值必须匹配
2.如果写了返回值类型,必须要有返回值
3.如果写了返回值,必须要有类型
4.没有返回值.返回值类型写void
5.return之后的语句不会再调用
```

## 方法的参数

参数:在方法执行的时候,给方法传递的信息

public static 返回值类型 方法名(形参){

​	方法体

}

方法(实参)

## 方法的重载

方法的名字相同,参数的个数不同或者类型不同,会自动匹配重载

和返回值没有关系

在执行过程中,程序会自动根据参数去找对应的方法,执行

方法的重载可以让我们省去起名字的烦恼



### ==

java中的 == 相当于Python中的is 指的是内存地址相等

java中的  equals() 比较的是值是否相等  类似于Python中的==  

# 面向对象

## 类的五大成分之一

成员变量  方法 构造器   代码块 内部类 

```
写代码
	类要使用class 来定义
	属性:成员变量直接写在类中的变量(写在方法中的变量  局部变量)
	方法:不写staic的成员方法
java分为两种数据类型
	1.基本数据类型
	2.引用数据类型 String和我们创建的所有类
//去掉static就是成员方法
public void test(){
    
}
创建对象
类 引用 = new 类()
```

## this 关键字

```
调用方法的时候,java会自动把对象传递给方法,在方法中用this来接收
this  当前类的对象
this 可以在方法内部获取对象中的属性信息
this还可以区分局部变量和成员变量
```

## 构造方法

语法

java 会自动的赠送给每一个类一个无参数的构造方法

如果自己定义了构造方法,,可以传递参数.java就不再赠送这个构造方法了,系统会调用你写的构造方法

在创建对象的时候,自动调用的方法

​	public 类名(){

​		}

## 构造方法的重载

构造方法也是方法,也可以进行重载

作用:可以有更多的方法去创建对象

使用this可以访问类中其他的构造方法  this()

![1591869457075](C:\Users\ADMINI~1\AppData\Local\Temp\1591869457075.png)

## static 静态

java面向对象中的类

static  int i = 47; 设置静态变量  对象.i改变的话 全局都会改变     两个对象调用i指的是同一块内存区域
推荐使用  类名.i  类名.变量

特点

​	1.数据共享

​	2.属于类的,并不属于对象

​	3.优先于对象产生的



通用构造器,静态构造器

创建对象的过程():

​	1.静态构造器

​	2.通用构造器

​	3.构造方法  ->创建对象  按照顺序走

由于创建对象的过程是在静态文件内容加载完成之后,在静态方法和静态块里是不能使用this来调用参数的    静态的内容推荐使用类名去访问.

​	

## 包

一般使用域名的翻转

创建包   com.lyy.www  可以理解为com文件夹下的lyy文件夹下的www

在代码中 需要写package 包名

在自己文件夹(相同包下)下 使用其他类不需要导包,在其他文件夹下就找不到那个类 就需要导包

在java.lang下的所有内容都不需要导包  比如 sout(system out printlen())   String



## 访问权限(权限修饰符)

1.public  公共的  所有人都可以访问

2.default  默认的缺省 

3.protected  包访问权限,在自己包里可以随便使用

3.private  私有的

用的最多的是private和public

![1592275942134](C:\Users\ADMINI~1\AppData\Local\Temp\1592275942134.png)

## setter和getter

成员变量一般使用setter和getter

setter主要是给成员变量赋值,做一定的保护

getter 从成员变量中获取数据



在 idea中快捷生成

右键  generate -> getter and setter  全选  会自动生成





## 继承

子类可以继承父类中除了私有内容的所有内容. public class B extends A{}



## super关键字

super 表示父类中的内容

This表示自己类中的内容  用super和this来区分父类和子类中重名的变量



创建对象的时候:先创建父类的对象然后创建子类的对象



小总结

 super可以获取到父类中的内容

可以调用父类中的构造方法,必须写在子类构造方法的第一行 如果父类的构造方法是无参数的,可以不写,如果父类没有无参数的构造,必须要写super

因为可以有好几个构造方法.



## 方法的重写

重写  子类对父类方法的重写

子类中的方法必须和父类中的方法完全一致,重写又被称为方法的覆盖.

super可以调用父类中被子类重写的方法.



## 多态

多态 : 同一个对象拥有多种形态

​	同一个类型的对象,执行不同法人行为,在不同的状态下,会表现出不同的行为特征.

多态的识别技巧

​	对于方法的调用,方法看左边,运行看右边

​	对于变量的调用,方法看左边,运行看左边

作用: 把不同的数据类型进行统一,让程序具有超强的可扩展性



小知识点:

​	1.把子类的对象赋值给父类的变量  -> 向上转型 

​	animal ani1 = new cat()

​	缺点: 屏蔽掉子类特有的方法  比如说猫 赋值给动物 然后动物便不能调用猫特有的方法  抓老鼠.可以再使用向下转型  cat cc = (cat)ani1

​	2.把父类的变量转化回子类的变量 ->向下转型

​	向下转型有可能有风险,java要求必须要写强制类型转换

​	(转换之后的数据类型) 变量

### 	小结

​		有继承/实现关系的两个类型就可以强制类型转换,编译阶段不会报错,但是运行阶段可能会出现异常ClassCastException

​		java 建议在进行强制类型转换之前先判断变量的真实类型,再强制类型转换

​		语法   变量  instanceof 类型  判断前面的变量是否是后面的或者类型或者其子类类型才返回True

## final关键字

1.被final修饰的变量,不可以被改变.又被称为常量

2 被final修饰的方法不能被重写  和static同位置  public finalvoid fun(){}

3.被final修饰的类不可以被继承

final 总结  就是不可变

## 抽象

![1591956071709](C:\Users\ADMINI~1\AppData\Local\Temp\1591956071709.png)

## 接口

接口实际上是一种特殊的抽象类,接口中全部都是抽象方法和常量,没有其他成分.

接口中所有的方法都是抽象方法,

接口使用interface来声明



能继承接口的只能是接口，接口和类的关系只能是实现关系

### 接口有啥用

​	接口体现的是规范思想,实现接口的类必须重写完接口中全部的抽象方法.  规范== 约束

类只能单继承，接口支持多实现.接口称为被实现,实现接口的类称为实现类

 接口同样具有多态性

接口可以把很多不相关的东西进行整合

### 特点 

接口中所有的方法都是抽象方法 都是公开的‘所以可以省略public abstruct不写

接口中所有的变量都是全局静态变量

子类  继承  父类

实现类  实现  接口

## 成员变量初识值

java中所有的变量必须先声明后赋值才能使用

java中的成员变量，再创建对象的时候都会执行一次初始化操作，都会给一个默认值

基本数据类型默认值都是0  包括boolean  -> false  在计算机语言中false也是0

引用数据类型 比如自己写的类 和 string  都是null

null表示空,什么都没有,占位

## object类

一切皆为对象  什么是一种什么   就要用继承

所有的东西都是对象

在java中的所有的类都是继承object

object是一个类  所有类的跟

我们写的类即使不写继承关系

## equals和==

equals相当于python的==   值相等

==相当于python的is   内存地址

equals如果子类不重写 默认调用的是父类object的equals方法,我们

在子类中可以重写equals判断的方法,对要进行判断的两个对象的属性进行自己逻辑的判断.这样就也可以判断不同对象值相等的时候,返回true

![image-20200613161824457](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200613161824457.png)

字符串中重写了equals方法

![image-20200613162100369](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200613162100369.png)

string str3 = new String("杠精")   其实是创建了一个杠精对象创建了一个string对象 string对象指向杠精  

字符串的判断一定是用equals

## tostring方法

toString()对一个对象的字符串的表示形式   父类中默认的toString返回的是

包名+类名+@+内存地址

java推荐子类重写toString方法  idea可以快捷生成 generate

## objects类

objects类的使用

objects类与object还是继承关系

objects类是从JDK1.7之后才有的

objects的方法

​	1.public static boolean equals(object a, object b)

​			-比较两个对象的

​			-底层进行非空判断,从而可以避免空指针异常,更安全

​	2.这个方法比较鸡肋,不怎么会使用

​		System.out.println(Objects.isNull());

​		判断变量是否为NULL,为null则返回true



```
package com.java.objects_test;
import java.util.Objects;
/**
 *
 *
 * 源码中的书写方法
 public static boolean equals(Object a, Object b) {
 return (a == b) || (a != null && a.equals(b));
 }
 * */

public class test_objects {

    public static void main(String[] args) {
        student s1 = new student();
        student s2 = new student();
        System.out.println(s1.equals(s2));
        System.out.println(Objects.equals(s1, s2));
    }
}

```



## instanceof关键字

判断某某某对象是不是xx类型的

![image-20200613163645855](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200613163645855.png)

![image-20200613231311339](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200613231311339.png)

异常的家族体系

## 异常的分类

1.Runtimeexception   运行时异常,一般不手动处理 出问题了才处理

2.其它exception  必须要经过手动处理

3.Error  一般是系统级错误  

## 异常的处理

try{

}

catch (){

}

finally{

}

## 异常的处理_throws和throw

## 

## Date

Date d1 = new Date();   创建时间对象

```
package com.java.Date;
import java.util.Date;
/**
 构造器
    public Date(): 创建当前系统的此刻日期时间
    public Date(long time);  将传进来的时间毫秒值转换成为日期时间


 * */

public class DateDemo1 {

    public static void main(String[] args) {
        Date d1 = new Date();
//        //打印出人类可读的时间格式
//        System.out.println(d1);
//
//        long l1 = d1.getTime();
//        //时间戳,时间毫秒值
//        System.out.println(l1);
        //计算程序流程时间
//        long st = new Date().getTime();
//        for (int i=1; i< 100000; i++){
//            System.out.println("输出+"+i);
//        }
//        long e1 = new Date().getTime();
//        System.out.println((e1 - st)/1000.0);
        System.out.println(d1);
        //拿到此刻时间往后走121秒
        long time = d1.getTime() + 121*1000;
        Date d2 = new Date(time);
        System.out.println(d2);
    }
}

```



DateFormat作用





